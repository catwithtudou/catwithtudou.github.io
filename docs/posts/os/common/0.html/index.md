# 程序运行原理Thinking


# 程序运行原理 Thinking

> 以下是个人理解（大白话较多）

## 程序是如何运行起来的

首先对于程序，可以简单理解为可执行的代码，程序是静态的，即存储在磁盘上。

而如果想要程序处理数据，完成计算任务，就必须把程序从外部加载到内存中。加载到内存中后就会在操作系统的管理调度下交给CPU去执行，将该程序运行起来。而程序被运行起来后就可以被称作为**进程**。

> 进程除了包含可执行的代码，还包括进程在运行期间使用的内存堆空间、栈空间、供操作系统管理用的数据结构等。

而如果**从指令角度看**，那就是操作系统把可执行代码加载到内存中后生成相应的数据结构和变量，而生成这些就需要在进程的堆空间申请相应的内存空间，并把内存的首地址信息记录在进程的栈中。

> 堆是一块无序的内存空间，任何时候进程需要申请内存，都会从堆空间中分配，分配到的内存地址则记录在栈中。而栈主要是来记录函数内部的局部变量、堆空间分配的内存空间地址等。

最后在内存空间后，就可以从可执行代码的起始位置**读取指令交给CPU**顺序执行。指令执行过程中所遇到的跳转指令，就可能是由我们常见的循环、控制判断等导致的。且每次函数调用时，就会利用到栈帧，函数在栈顶执行，且每个栈帧都是隔离的即不发生混乱。

## 一台计算机如何同时处理多个任务

主要依靠操作系统的**CPU分时共享技术**，即宏观上是并行，微观上是串行的。

所以进程不是总在运行，进程的生命周期中主要有三种状态：**运行、就绪、阻塞**。

不同进程轮流在CPU上执行，就会涉及到**进程之间的切换**问题。线程也是同样的问题，但线程的切换代价更小。

一台计算机同时处理多个任务的性能还是要看**其进程调度**，或者**线程调度**，本质就是为了保证每一个合理的任务尽可能地被处理运行。

## 系统为什么会变慢或者崩溃

这里的问题以web应用程序作为例子。

**高并发请求**，导致系统变慢或者严重至崩溃，也就是用户请求响应变慢，而这里可能导致的原因可能就是**资源限制导致的线程阻塞问题**，一个线程阻塞可能就会影响到其他线程的运行，被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释 放当前已经占据的资源，在系统中一边等待一边消耗资源。

而发生阻塞的原因可能就是出现了等待其他服务完成或者等待信号，最常见的就是我们平常遇见的排队等锁，而出现**锁**就涉及到了**线程安全**问题。

解决的主要手段，在单机中可以通过设计更优的**保证线程安全的执行调度**方案，而在多机中就可以使用**分布式系统架构**，通过集群来共同处理用户的并发请求，减少资源限制的压力，必要时可以在入口进行限流以减少并发请求数，在于应用内进行降级以减小线程的资源消耗。


